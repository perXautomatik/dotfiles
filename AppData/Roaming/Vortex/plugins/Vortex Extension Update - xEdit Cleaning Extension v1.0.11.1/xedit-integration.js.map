{"version":3,"sources":["webpack://xedit-integration/webpack/bootstrap","webpack://xedit-integration/./src/index.ts","webpack://xedit-integration/external \"vortex-api\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,8BAAY;AACzC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS,kDAAkD,WAAW;AAC/F,yBAAyB,SAAS,iBAAiB,WAAW;AAC9D,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,4EAA4E;AAC5E;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,4EAA4E;AAC5E;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,2DAA2D,UAAU;AACrE;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wFAAwF,gBAAgB,qDAAqD;AACtM;AACA,yCAAyC,wFAAwF,gBAAgB,+CAA+C;AAChM;AACA;AACA,qCAAqC,wFAAwF,gBAAgB,mDAAmD;AAChM;AACA,qBAAqB,SAAS,2DAA2D,SAAS;AAClG,qBAAqB,WAAW,yDAAyD,WAAW;AACpG,gCAAgC,WAAW,oEAAoE,WAAW,oBAAoB,WAAW;AACzJ;AACA;AACA;AACA;AACA;AACA,qFAAqF,kBAAkB;AACvG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+GAA+G,eAAe;AAC9H;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;AC/KA,uC","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.runxEdit = exports.setCleaning = exports.doNotCleanMessages = exports.excludedPlugins = exports.gameSupportData = void 0;\r\nconst vortex_api_1 = require(\"vortex-api\");\r\nexports.gameSupportData = [\r\n    {\r\n        game: \"skyrimse\",\r\n        exeName: \"SSEEdit\",\r\n        gameParam: \"-sse\"\r\n    },\r\n    {\r\n        game: \"skyrim\",\r\n        exeName: \"TES5Edit\",\r\n        gameParam: \"-tes5\"\r\n    },\r\n    {\r\n        game: \"skyrimvr\",\r\n        exeName: \"TES5VREdit\",\r\n        gameParam: \"-tes5vr\"\r\n    },\r\n    {\r\n        game: \"fallout4\",\r\n        exeName: \"FO4Edit\",\r\n        gameParam: \"-fo4\"\r\n    },\r\n    {\r\n        game: \"oblivion\",\r\n        exeName: \"TES4Edit\",\r\n        gameParam: \"-tes4\"\r\n    },\r\n    {\r\n        game: \"enderal\",\r\n        exeName: \"EnderalEdit\",\r\n        gameParam: \"-enderal\"\r\n    },\r\n    {\r\n        game: \"fallout3\",\r\n        exeName: \"FO3Edit\",\r\n        gameParam: \"-fo3\"\r\n    },\r\n    {\r\n        game: \"falloutnv\",\r\n        exeName: \"FNVEdit\",\r\n        gameParam: \"-fnv\"\r\n    },\r\n    {\r\n        game: \"fallout4vr\",\r\n        exeName: \"FO4VREdit\",\r\n        gameParam: \"-fo4vr\"\r\n    },\r\n    {\r\n        game: \"fallout76\",\r\n        exeName: \"FO76Edit\",\r\n        gameParam: \"-fo76\"\r\n    },\r\n    {\r\n        game: \"morrowind\",\r\n        exeName: \"TES3Edit\",\r\n        gameParam: \"-tes3\"\r\n    },\r\n];\r\nexports.excludedPlugins = [\"skyrim.esm\", \"fallout4.esm\", \"falloutnv.esm\", \"fallout3.esm\", \" oblivion.esm\", \"seventysix.esm\", \"enderal - forgotten stories.esm\"];\r\nexports.doNotCleanMessages = [\r\n    'Do not clean ITM records, they are intentional and required for the mod to function. It is safe to undelete records, but do not do anything other than that.',\r\n    'Rengør ikke ITM-poster: de er forsætlige og krævede for at mod’en fungerer. Det er sikkert at gendanne poster, men gør ikke andet end dét.',\r\n    'ITM-Einträge in diesem Plugin sollten nicht gesäubert werden, sie sind absichtlich enthalten und werden benötigt, damit die Mod richtig funktioniert. Gelöschte Einträge wiederherzustellen ist in Ordnung, alles andere aber nicht.',\r\n    'No limpiar las referencias ITM (iguales al master), ya que son intencionales y necesarias para que el Mod funcione. Sí es seguro restaurar las UDR (referencias borradas), pero no haga más que eso.',\r\n    'IMTレコードはクリーンしないでください。これらは意図的に残されたデータであり、Modを機能させるために必要です。削除の取り消しは安全に行えますが、それ以外のことは行わないでください。',\r\n    'ITM 자료를 삭제하지 마십시오. 모드가 정상 작동하기 위해 의도적으로 남겨진 자료입니다. 삭제를 취소하는 것 이외에는 안전하지 않습니다.',\r\n    'Nie czyść rekordów ITM, są one zamierzone i potrzebne do działania tego moda. Jest bezpieczne aby cofnąć usunięcie rekordów (UDR), ale nie rób nic innego ponad to. ',\r\n    'Não apagar os registos ITM. São intencionais e necessárias para o funcionamento do mod. É seguro restaurar os registos, mas não faça nada mais que isso.',\r\n    'Não apague os registros ITM. Eles são intencionais e necessários para que o mod funcione. É seguro restaurar os registros, mas nada mais além disso.',\r\n    'Не очищать ITM-записи. \"Грязные\" правки оставлены специально и требуются для функционирования мода. Восстановить удаленные записи (UDR) можно безопасно, но идентичные мастерфайлу лучше оставить.',\r\n    'Städa inte bort ITM records, de är avsiktliga och krävs för att modden ska fungera. Det är säkert att återställa records, men gör ingenting förutom det.',\r\n    '不干净。\"脏\"数据是故意的，这是mod需要的功能。'\r\n];\r\nconst xEditParams = {\r\n    \"quickautoclean\": [\"{gamePara}\", \"-quickautoclean\", \"-autoexit\", \"-autoload\", \"{pluginName}\"],\r\n    \"autoloadplugin\": [\"{gamePara}\", \"-quickedit: {pluginName}\"],\r\n    \"autoloadall\": [\"{gamePara}\", \"-autoload\"]\r\n};\r\nlet cleaningInProgress = false;\r\nlet pluginBeingCleaned = \"\";\r\nfunction setCleaning(status, pluginName = \"\") {\r\n    cleaningInProgress = status;\r\n    pluginBeingCleaned = pluginName;\r\n}\r\nexports.setCleaning = setCleaning;\r\nfunction init(context) {\r\n    context.requireVersion('^1.1.0');\r\n    context.requireExtension('gamebryo-plugin-management');\r\n    context.registerAction('gamebryo-plugin-icons', 300, 'xEdit', {}, 'Open xEdit', () => {\r\n        runxEdit('', context.api, [...xEditParams['autoloadall']]);\r\n    }, () => {\r\n        const activeGameId = vortex_api_1.selectors.activeGameId(context.api.store.getState());\r\n        return exports.gameSupportData.find(g => g.game === activeGameId) ? true : false;\r\n    });\r\n    context.registerAction('gamebryo-plugins-action-icons', 500, 'xEdit', {}, 'Clean with xEdit', instanceIds => {\r\n        runxEdit(instanceIds[0], context.api, [...xEditParams['quickautoclean']]);\r\n    }, instanceIds => {\r\n        const activeGameId = vortex_api_1.selectors.activeGameId(context.api.store.getState());\r\n        return exports.gameSupportData.find(g => g.game === activeGameId) ? true : false;\r\n    });\r\n    context.registerAction('gamebryo-plugins-action-icons', 100, 'xEdit', {}, 'Open in xEdit', instanceIds => {\r\n        runxEdit(instanceIds[0], context.api, [...xEditParams['autoloadplugin']]);\r\n    }, instanceIds => {\r\n        const activeGameId = vortex_api_1.selectors.activeGameId(context.api.store.getState());\r\n        return exports.gameSupportData.find(g => g.game === activeGameId) ? true : false;\r\n    });\r\n    context.once(() => {\r\n        vortex_api_1.util.installIconSet('xedit-icons', `${__dirname}/xediticon.svg`);\r\n        context.api.onStateChange(['session', 'base', 'toolsRunning'], (previous, current) => __awaiter(this, void 0, void 0, function* () {\r\n            if (cleaningInProgress && (Object.keys(previous).length > 0) && (Object.keys(current).length === 0)) {\r\n                context.api.sendNotification({\r\n                    type: \"success\",\r\n                    title: \"Plugin Cleaning Completed\",\r\n                    message: `${pluginBeingCleaned} was cleaned with xEdit.`,\r\n                    group: \"xEdit-cleaning-done\",\r\n                    displayMS: 10000\r\n                });\r\n                setCleaning(false);\r\n                vortex_api_1.log(\"debug\", \"xEdit plugin cleaning completed\");\r\n            }\r\n        }));\r\n    });\r\n}\r\nfunction runxEdit(pluginName, api, params) {\r\n    const store = api.store;\r\n    const activeGameId = vortex_api_1.selectors.activeGameId(store.getState());\r\n    const pluginData = vortex_api_1.util.getSafe(store.getState(), ['session', 'plugins', 'pluginInfo', pluginName.toLowerCase()], undefined);\r\n    if (pluginData) {\r\n        const lootMessages = pluginData.messages || [];\r\n        const doNotCleanMessage = lootMessages.find(m => exports.doNotCleanMessages.includes(m.value));\r\n        const missingMaster = pluginData.warnings['missing-master'];\r\n        if (doNotCleanMessage)\r\n            return api.sendNotification({ type: 'warning', title: `Cannot clean this plugin`, message: `Vortex could not clean ${pluginData.name}, please check the LOOT messages.`, displayMS: 5000 });\r\n        if (missingMaster)\r\n            return api.sendNotification({ type: 'warning', title: `Cannot clean this plugin`, message: `Vortex could not clean ${pluginData.name} as it has missing masters.`, displayMS: 5000 });\r\n    }\r\n    if (exports.excludedPlugins.indexOf(pluginName.toLowerCase()) !== -1 && params.includes('-quickautoclean'))\r\n        return api.sendNotification({ type: 'warning', title: `Cannot clean this plugin`, message: `Vortex could not clean ${pluginData.name} as it is the game master file.`, displayMS: 5000 });\r\n    const xEditData = exports.gameSupportData.find(g => g.game === activeGameId);\r\n    params.indexOf('{gamePara}') !== -1 && xEditData.gameParam ? params[params.indexOf('{gamePara}')] = xEditData.gameParam : null;\r\n    params.indexOf('{pluginName}') !== -1 && pluginName !== '' ? params[params.indexOf('{pluginName}')] = pluginName : null;\r\n    params.indexOf('-quickedit:{pluginName}') !== -1 && pluginName !== '' ? params[params.indexOf('-quickedit:{pluginName}')] = `-quickedit:${pluginName}` : null;\r\n    const gamePath = vortex_api_1.util.getSafe(store.getState(), ['settings', 'gameMode', 'discovered', activeGameId, 'path'], undefined);\r\n    const tools = vortex_api_1.util.getSafe(store.getState(), ['settings', 'gameMode', 'discovered', activeGameId, 'tools'], undefined);\r\n    const xEditKey = tools ? Object.keys(tools).find(t => t === xEditData.exeName) : undefined;\r\n    const xEditTool = xEditKey ? tools[xEditKey] : undefined;\r\n    if (!xEditTool || !xEditTool.path)\r\n        return api.showErrorNotification(`xEdit not found`, `Vortex could not find ${xEditData.exeName}. Please check the tool in your starter dashlet is pointing to the right place.`);\r\n    api.runExecutable(xEditTool.path, params, {\r\n        cwd: gamePath,\r\n        suggestDeploy: false,\r\n        shell: false,\r\n        onSpawned: () => api.store.dispatch(vortex_api_1.actions.setToolRunning(xEditTool.path, Date.now(), true))\r\n    }).then(params.includes('-quickautoclean') ? setCleaning(true, pluginData.name || pluginName) : null)\r\n        .catch(err => {\r\n        if (err.errno === 'ENOENT') {\r\n            api.showErrorNotification(`xEdit not found`, `Failed to run tool. Vortex could not find xEdit at ${xEditTool.path}. Please check the tool in your starter dashlet is pointing to the right place.`);\r\n        }\r\n        else\r\n            console.log(err);\r\n    });\r\n}\r\nexports.runxEdit = runxEdit;\r\nexports.default = init;\r\n","module.exports = require(\"vortex-api\");"],"sourceRoot":""}