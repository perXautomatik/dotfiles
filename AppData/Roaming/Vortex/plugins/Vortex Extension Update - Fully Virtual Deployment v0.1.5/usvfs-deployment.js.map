{"version":3,"sources":["webpack://usvfs-deployment/webpack/bootstrap","webpack://usvfs-deployment/./src/index.ts","webpack://usvfs-deployment/external \"bluebird\"","webpack://usvfs-deployment/external \"electron\"","webpack://usvfs-deployment/external \"./usvfs\"","webpack://usvfs-deployment/external \"path\"","webpack://usvfs-deployment/external \"turbowalk\"","webpack://usvfs-deployment/external \"vortex-api\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,mCAAmC,mBAAO,CAAC,0BAAU;AACrD,mBAAmB,mBAAO,CAAC,0BAAU;AACrC,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,2BAA2B,mBAAO,CAAC,8BAAY;AAC/C,oCAAoC,mBAAO,CAAC,4BAAW;AACvD,qBAAqB,mBAAO,CAAC,8BAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,kBAAkB;AACjH;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mDAAmD,gBAAgB,GAAG,oBAAoB,mDAAmD;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB,iBAAiB;AACrC;AACA;AACA,8DAA8D,WAAW,MAAM,gBAAgB,GAAG,oBAAoB,0CAA0C;AAChK;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;;;;;;;;;;;;ACvMA,qC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,uC","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bluebird_1 = __importDefault(require(\"bluebird\"));\r\nconst electron_1 = require(\"electron\");\r\nconst path = __importStar(require(\"path\"));\r\nconst usvfs = __importStar(require(\"node-usvfs\"));\r\nconst turbowalk_1 = __importDefault(require(\"turbowalk\"));\r\nconst vortex_api_1 = require(\"vortex-api\");\r\nconst app = electron_1.app !== undefined ? electron_1.app : electron_1.remote.app;\r\nconst METHOD_ID = 'usvfs-deployment';\r\nconst UNSUPPORTED_GAMES = [\r\n    'thesims4',\r\n    'kingdomcomedeliverance',\r\n];\r\nclass USVFSDeploymentMethod {\r\n    constructor(api) {\r\n        this.id = METHOD_ID;\r\n        this.name = 'USVFS Deployment';\r\n        this.description = 'Deployment happens only in memory and affects only '\r\n            + 'applications started from Vortex';\r\n        this.isFallbackPurgeSafe = false;\r\n        this.priority = 15;\r\n        this.mAPI = api;\r\n    }\r\n    detailedDescription(t) {\r\n        return t(this.description);\r\n    }\r\n    isSupported(state, gameId, modTypeId) {\r\n        var _a;\r\n        if (process.platform !== 'win32') {\r\n            return {\r\n                description: t => t('Only supported on Windows'),\r\n            };\r\n        }\r\n        const game = vortex_api_1.util.getGame(gameId);\r\n        if (((_a = game.compatible) === null || _a === void 0 ? void 0 : _a.usvfs) === false) {\r\n            return { description: t => t('Game doesn\\'t support usfvs') };\r\n        }\r\n        if (UNSUPPORTED_GAMES.indexOf(gameId) !== -1) {\r\n            return {\r\n                description: t => t('Incompatible with \"{{name}}\".', {\r\n                    replace: {\r\n                        name: vortex_api_1.selectors.gameName(state, gameId),\r\n                    }\r\n                }),\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n    userGate() {\r\n        return bluebird_1.default.resolve(bluebird_1.default.resolve());\r\n    }\r\n    prepare(dataPath, clean, lastActivation) {\r\n        if (clean) {\r\n            usvfs.ClearVirtualMappings();\r\n        }\r\n        this.mDataPath = dataPath;\r\n        this.mDeployed = [];\r\n        return bluebird_1.default.resolve();\r\n    }\r\n    finalize(gameId, dataPath, installationPath, progressCB) {\r\n        return bluebird_1.default.resolve(this.mDeployed);\r\n    }\r\n    getDeployedPath(input) {\r\n        return input;\r\n    }\r\n    activate(sourcePath, sourceName, dataPath, blackList) {\r\n        return vortex_api_1.fs.statAsync(sourcePath)\r\n            .then(() => {\r\n            usvfs.VirtualLinkDirectoryStatic(sourcePath, path.join(this.mDataPath, dataPath), { recursive: true });\r\n            return turbowalk_1.default(sourcePath, files => {\r\n                this.mDeployed.push(...files.map(entry => ({\r\n                    relPath: path.relative(sourcePath, entry.filePath),\r\n                    source: sourceName,\r\n                    time: entry.mtime,\r\n                })));\r\n            });\r\n        })\r\n            .catch(() => null);\r\n    }\r\n    deactivate(installPath, dataPath) {\r\n        return bluebird_1.default.resolve();\r\n    }\r\n    prePurge() {\r\n        return bluebird_1.default.resolve();\r\n    }\r\n    postPurge() {\r\n        return bluebird_1.default.resolve();\r\n    }\r\n    purge(installPath, dataPath) {\r\n        usvfs.ClearVirtualMappings();\r\n        return bluebird_1.default.resolve();\r\n    }\r\n    externalChanges(gameId, installPath, dataPath, activation) {\r\n        return bluebird_1.default.resolve([]);\r\n    }\r\n    isActive() {\r\n        return false;\r\n    }\r\n    isDeployed(installPath, dataPath, file) {\r\n        return bluebird_1.default.resolve(this.mDeployed.find(deployed => deployed.relPath === file.relPath) !== undefined);\r\n    }\r\n}\r\nfunction init(context) {\r\n    context.registerDeploymentMethod(new USVFSDeploymentMethod(context.api));\r\n    context.registerStartHook(1000, 'usvfs-run', call => {\r\n        const state = context.api.store.getState();\r\n        const activator = vortex_api_1.selectors.currentActivator(state);\r\n        if (activator !== METHOD_ID) {\r\n            return bluebird_1.default.resolve(call);\r\n        }\r\n        const stackErr = new Error();\r\n        return new bluebird_1.default((resolve, reject) => {\r\n            if (vortex_api_1.util.getSafe(state, ['session', 'base', 'activity', 'mods'], []).indexOf('deployment') !== -1) {\r\n                return resolve();\r\n            }\r\n            const deployCB = vortex_api_1.util.onceCB((err) => {\r\n                if (err !== null) {\r\n                    return reject(err);\r\n                }\r\n                else {\r\n                    return resolve();\r\n                }\r\n            });\r\n            deployCB.fromusvfs = true;\r\n            context.api.events.emit('deploy-mods', deployCB);\r\n        })\r\n            .then(() => vortex_api_1.fs.statAsync(call.executable))\r\n            .then(() => {\r\n            try {\r\n                usvfs.CreateProcessHooked(null, `${call.executable} ${call.args.join(' ')}`, call.options.cwd, Object.assign(Object.assign({}, process.env), call.options.env));\r\n            }\r\n            catch (err) {\r\n                err.stack = stackErr.stack;\r\n                return bluebird_1.default.reject(err);\r\n            }\r\n            return bluebird_1.default.reject(new vortex_api_1.util.ProcessCanceled('run through usvfs'));\r\n        })\r\n            .catch({ code: 'ENOENT' }, () => {\r\n            try {\r\n                const workingDir = call.options.cwd || path.dirname(call.executable);\r\n                usvfs.CreateProcessHooked(null, `cmd /C \"cd ${workingDir} && ${call.executable} ${call.args.join(' ')}\"`, 'c:\\\\', Object.assign(Object.assign({}, process.env), call.options.env));\r\n            }\r\n            catch (err) {\r\n                err.stack = stackErr.stack;\r\n                return bluebird_1.default.reject(err);\r\n            }\r\n            return bluebird_1.default.reject(new vortex_api_1.util.ProcessCanceled('run through usvfs'));\r\n        });\r\n    });\r\n    context.once(() => {\r\n        usvfs.CreateVFS({\r\n            logLevel: 2,\r\n            instanceName: 'vortex-usvfs',\r\n            debugMode: false,\r\n            crashDumpPath: path.join(app.getPath('temp'), 'usvfs_dumps'),\r\n            crashDumpType: 1,\r\n        });\r\n        usvfs.InitLogging();\r\n        usvfs.PollLogMessages(message => {\r\n            const tPos = message.indexOf('[');\r\n            const logLevel = {\r\n                D: 'debug',\r\n                I: 'info',\r\n                W: 'warning',\r\n                E: 'error',\r\n            }[message[tPos + 1]] || 'warning';\r\n            if ((logLevel === 'error') && (message.indexOf('never released the mutex') !== -1)) {\r\n                return true;\r\n            }\r\n            vortex_api_1.log(logLevel, message.slice(tPos + 4));\r\n            return true;\r\n        }, (err) => {\r\n            if (err !== null) {\r\n                context.api.showErrorNotification('USVFS logging no longer monitored', err);\r\n            }\r\n        });\r\n        context.api.onStateChange(['settings', 'mods', 'activator'], (prev, next) => {\r\n            const state = context.api.store.getState();\r\n            const gameMode = vortex_api_1.selectors.activeGameId(state);\r\n            if ((prev[gameMode] !== next[gameMode])\r\n                && ((prev[gameMode] === METHOD_ID)\r\n                    || (next[gameMode] === METHOD_ID))) {\r\n                context.api.events.emit('restart-helpers');\r\n            }\r\n        });\r\n    });\r\n    return true;\r\n}\r\nexports.default = init;\r\n","module.exports = require(\"bluebird\");","module.exports = require(\"electron\");","module.exports = require(\"./usvfs\");","module.exports = require(\"path\");","module.exports = require(\"turbowalk\");","module.exports = require(\"vortex-api\");"],"sourceRoot":""}