"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const vortex_api_1 = require("vortex-api");
const DUMMY_MOD_ID = 7777777;
const init = (context) => {
    function activateMod(gameId, modName) {
        var _a;
        const now = new Date();
        const hasExistingMod = !!((_a = context.api.getState().persistent.mods[gameId]) === null || _a === void 0 ? void 0 : _a[modName]);
        return hasExistingMod ? updateMod() : createMod();
        function createMod() {
            const mod = {
                id: modName,
                attributes: {
                    category: 33,
                    enableallplugins: true,
                    installTime: now,
                    logicalFileName: modName,
                    modId: DUMMY_MOD_ID,
                    modName: `EasyNPC Output - ${modName}`,
                    name: modName,
                    shortDescription: getShortDescription(),
                    version: '1.0.0',
                },
                installationPath: modName,
                state: 'installed',
                type: '',
            };
            return new Promise((resolve, reject) => {
                context.api.events.emit('create-mod', gameId, mod, (error) => __awaiter(this, void 0, void 0, function* () {
                    if (error != null) {
                        return reject(error);
                    }
                    resolve();
                }));
            });
        }
        function getShortDescription() {
            return `NPC overhaul merge generated by EasyNPC on ` +
                `${now.getFullYear()}-${zeroPad(now.getMonth() + 1, 2)}-${zeroPad(now.getDay(), 2)} ` +
                `${zeroPad(now.getHours(), 2)}:${zeroPad(now.getMinutes(), 2)}:${zeroPad(now.getSeconds(), 2)}`;
        }
        function updateMod() {
            const setAttribute = (name, value) => context.api.store.dispatch(vortex_api_1.actions.setModAttribute(gameId, modName, name, value));
            setAttribute('category', 33);
            setAttribute('installTime', now);
            setAttribute('logicalFileName', modName);
            setAttribute('modId', DUMMY_MOD_ID);
            setAttribute('modName', `EasyNPC Output - ${modName}`);
            setAttribute('name', modName);
            setAttribute('shortDescription', getShortDescription());
            setAttribute('version', '1.0.0');
            return Promise.resolve();
        }
    }
    function createLookupFile(profile, discovery, reportPath) {
        var _a, _b;
        const state = context.api.getState();
        const mods = state.persistent.mods[profile.gameId] || {};
        const stagingDir = vortex_api_1.selectors.installPathForGame(state, profile.gameId);
        const data = {
            files: {},
            filePriorities: [],
            mods: {},
            reportPath,
            stagingDir,
        };
        if (discovery.path) {
            data.gameDataPath = path_1.join(discovery.path, 'data');
        }
        for (const mod of Object.values(mods)) {
            const attributes = (mod.attributes || {});
            data.files[mod.id] = {
                id: attributes.fileId,
                isEnabled: (_b = (_a = profile === null || profile === void 0 ? void 0 : profile.modState[mod.id]) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : false,
                modId: attributes.modId,
            };
            if (attributes.modId) {
                data.mods[attributes.modId] = { name: attributes.modName };
            }
        }
        try {
            const enabledMods = new Set(Object.entries(data.files).filter(([_, file]) => file.isEnabled).map(([name]) => name));
            const dependencies = state.session['dependencies'];
            data.filePriorities = resolveFilePriorities(dependencies, enabledMods);
        }
        catch (_c) {
        }
        const lookupPath = path_1.join(os_1.tmpdir(), 'easynpc-vortex-bootstrap.json');
        fs_1.writeFileSync(lookupPath, JSON.stringify(data));
        return lookupPath;
    }
    function getCurrentDiscovery() {
        return vortex_api_1.selectors.currentGameDiscovery(context.api.getState());
    }
    function getCurrentProfile() {
        return vortex_api_1.selectors.activeProfile(context.api.getState());
    }
    function isGameSupported() {
        const profile = getCurrentProfile();
        return ['skyrim', 'skyrimse', 'skyrimvr', 'enderal', 'enderalse', 'fallout4', 'fallout4vr']
            .includes(profile.gameId);
    }
    function launchEasyNpc(parameters) {
        var _a;
        const reportPath = path_1.join(os_1.tmpdir(), 'easynpc-vortex-report.json');
        const sentinelContent = 'sentinel';
        fs_1.writeFileSync(reportPath, sentinelContent);
        const profile = getCurrentProfile();
        const discovery = getCurrentDiscovery();
        const dataPath = createLookupFile(profile, discovery, reportPath);
        const tools = ((_a = context.api.getState().settings.gameMode.discovered[profile.gameId]) === null || _a === void 0 ? void 0 : _a.tools) || {};
        const easyNpcTool = Object.values(tools).find(t => t.path && path_1.basename(t.path).toLowerCase() == "easynpc.exe");
        if (easyNpcTool) {
            context.api.runExecutable(easyNpcTool.path, (easyNpcTool.parameters || []).concat(parameters || []).concat([
                `--report-path=${reportPath}`,
                `--vortex-manifest="${dataPath}"`,
            ]), {
                shell: false,
                suggestDeploy: true,
            })
                .catch(err => {
                if (err.errno === 'ENOENT') {
                    context.api.showErrorNotification('EasyNPC executable not found', `The path '${easyNpcTool.path}' is invalid. Check the tool configuration in the Vortex dashboard.`);
                }
                else {
                    console.log(err);
                }
            })
                .then(() => {
                var reportFile = fs_1.readFileSync(reportPath, 'utf8');
                if (reportFile === sentinelContent) {
                    return;
                }
                var report = JSON.parse(reportFile);
                if (report.modName) {
                    activateMod(profile.gameId, report.modName);
                }
            })
                .catch(() => {
                context.api.showErrorNotification('Failed to read report file.', `The EasyNPC report file at ${reportPath} either does not exist or could not be opened. ` +
                    `If you completed a build, then you may need to restart Vortex in order to see the new mod.`);
            });
        }
        else {
            context.api.showErrorNotification('EasyNPC not configured', 'Could not find a registered tool named EasyNPC.exe. Check that this tool is configured in the Vortex dashboard.' +
                JSON.stringify(tools));
        }
    }
    function resolveFilePriorities(dependencies, enabledMods) {
        class FileResolutionContext {
            constructor() {
                this.modIds = new Set();
                this.overriddenModIds = new Set();
            }
            findWinner() {
                for (const modId of this.modIds) {
                    if (!this.overriddenModIds.has(modId)) {
                        return modId;
                    }
                }
                return null;
            }
        }
        const acc = new Map();
        for (const [modId, conflictSettings] of Object.entries(dependencies.conflicts)) {
            if (!enabledMods.has(modId)) {
                continue;
            }
            for (const setting of conflictSettings) {
                for (const fileName of setting.files) {
                    let context = acc.get(fileName);
                    if (!context) {
                        context = new FileResolutionContext();
                        acc.set(fileName, context);
                    }
                    context.modIds.add(modId);
                    if (setting.suggestion === 'after') {
                        context.overriddenModIds.add(setting.otherMod.id);
                    }
                }
            }
        }
        return [...acc.entries()]
            .map(([path, context]) => ({ path, winningFileId: context.findWinner() }))
            .filter(x => !!x.winningFileId);
    }
    context.registerAction('mod-icons', 998, 'launch-simple', {}, 'Launch EasyNPC', () => launchEasyNpc(), isGameSupported);
    context.registerAction('mod-icons', 999, 'conflict', {}, 'EasyNPC Post-Build', () => launchEasyNpc(['-z']), isGameSupported);
};
function zeroPad(value, digits) {
    return String(value).padStart(digits, '0');
}
exports.default = init;
